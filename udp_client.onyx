#load "core/std"
#load "src/module"

use package core
onyx_net :: package onyx_net

octets_to_addr :: (a, b, c, d: u8) -> u32 {
    return (cast(u32) a << 24) |
           (cast(u32) b << 16) |
           (cast(u32) c << 8)  |
           (cast(u32) d << 0);
}

main :: (args) => {
    //
    // 'null' signifies that this host should not bind a socket
    // to a port. Only 1 peer is needed, as this is only connecting
    // to one server.
    host: ^onyx_net.Host;
    if host', err := onyx_net.host_create(null, 1); err != .None {
        println(err);
    }

    addr: net.Socket_Address;
    addr.addr = octets_to_addr(127, 0, 0, 1);
    addr.port = 8080;
    peer := onyx_net.host_connect(host, ^addr, 2);

    while true {
        println("Waiting for events....");
        for host->get_events(timeout=1000) {
            printf("{*}\n", it);

            if it.type == .Message {
                packet := new(onyx_net.Packet);
                packet.flags |= .Reliable;
                packet.data = "HELLO";

                onyx_net.peer_send(it.peer, 0, packet);
            }
        }
    }
}

old_main :: (args) => {
    udp_socket, err := net.socket_create(.Inet, .Dgram);
    assert(err == .None, "Failed to create socket");
    defer udp_socket->close();

    dest_addr: net.Socket_Address;
    dest_addr.port = 8080;
    // dest_addr.addr = octets_to_addr(45, 76, 30, 19);
    dest_addr.addr = octets_to_addr(127, 0, 0, 1);


    random.set_seed(12341);
    for 10 {
        to_send := random.string(50, alpha_numeric=true);

        sent_bytes := udp_socket->sendto(to_send, ^dest_addr);
        printf("Sent {} bytes!\n", sent_bytes);

        string.free(to_send);
    }

    for 1000 {
        recv_buffer: [1024] u8;
        recv_addr, recv_bytes := udp_socket->recvfrom(recv_buffer);

        tmp := recv_addr->addr_as_str();
        printf("{} sent {} bytes\n", tmp, recv_bytes);
        string.free(tmp);

        printf("{}\n", recv_buffer[0 .. recv_bytes]);
    }
}
